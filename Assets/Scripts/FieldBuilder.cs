using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Random = UnityEngine.Random;

namespace RandomDungeonWithBluePrint
{
    public static class FieldBuilder
    {
        public static Field Build(FieldBluePrint bluePrint)
        {
            var field = new Field
            {
                Size = bluePrint.Size,
                MaxRoomNum = Random.Range(bluePrint.MinRoomNum, bluePrint.MaxRoomNum + 1)　// intのRandom.Rangeの仕様の都合で+1
            };

            MakeSection(field, bluePrint);　// 盤面を区分けする
            MakeRooms(field); // 部屋を作る
            MakeBranches(field, bluePrint); // 道を作る
            field.BuildGrid(); // サイズと部屋と道を二次元平面にする
            return field;
        }

        private static void MakeSection(Field field, FieldBluePrint bluePrint)
        {
            field.Sections = bluePrint.Sections.Select(s => new Section(s)).ToList();
        }

        private static void MakeRooms(Field field)
        {
            MakeIndispensableRooms(field);
            MakeStochasticRooms(field);
            MakeRelay(field);
        }

        private static void MakeIndispensableRooms(Field field)
        {
            var targetSections = field.Sections.Where(s => s.RoomIndispensable)
                .OrderBy(s => s.Index)
                .Take(field.MaxRoomNum);
            foreach (var section in targetSections)
            {
                MakeRoom(section);
            }
        }

        private static void MakeStochasticRooms(Field field)
        {
            // 部屋の数が限界に達するか、部屋を作る場所がなくなれば終了
            while (!field.RoomIsFull && field.ExistRoomToBeMake)
            {
                var targetSection = RaffleForMakeRoom(field);
                MakeRoom(targetSection);
            }
        }

        private static void MakeRoom(Section section)
        {
            var sectionWithPadding = section.Rect.AddPadding(2);
            var roomRect = GetRoomRect(sectionWithPadding, section.MinRoomSize);
            var safeArea = sectionWithPadding.SafeAreaOfInclusion(roomRect);
            roomRect.x = Random.Range(safeArea.xMin, safeArea.xMax);
            roomRect.y = Random.Range(safeArea.yMin, safeArea.yMax);
            section.Room = new Room(roomRect);

            var mod = Random.Range(0, 10) % 2;
            foreach (var direction in Constants.Direction.FourDirections)
            {
                var edgePositions = section.Room.Edge[direction].ToList();
                for (var i = 0; i < edgePositions.Count; i++)
                {
                    if (i % 2 == mod)
                    {
                        section.Room.SetJoint(direction, edgePositions[i]);
                    }
                }
            }
        }

        private static RectInt GetRoomRect(RectInt source, Vector2Int minSize)
        {
            if (minSize.x < 0 || minSize.y < 0 || source.width < minSize.x || source.height < minSize.y)
            {
                throw new ArgumentOutOfRangeException();
            }

            // Random.Rangeの仕様でmax - 1が最大値になる
            return new RectInt(source.x, source.y, Random.Range(minSize.x, source.width + 1), Random.Range(minSize.y, source.height + 1));
        }

        private static void MakeRelay(Field field)
        {
            foreach (var section in field.Sections.Where(s => !s.ExistRoom))
            {
                var padding = section.Rect.AddPadding(2);
                var point = new Vector2Int(Random.Range(padding.xMin, padding.xMax), Random.Range(padding.yMin, padding.yMax));
                section.Relay = new Relay(section.Index, point);
            }
        }

        private static Section RaffleForMakeRoom(Field field)
        {
            var candidate = field.Sections.Where(s => !s.ExistRoom).OrderBy(s => s.Index).ToList();
            var rand = Random.Range(0, candidate.Sum(c => c.MakeRoomWeight));
            var pick = 0;
            for (var i = 0; i < candidate.Count; i++)
            {
                if (rand < candidate[i].MakeRoomWeight)
                {
                    pick = i;
                    break;
                }

                rand -= candidate[i].MakeRoomWeight;
            }

            return candidate[pick];
        }

        private static void MakeBranches(Field field, FieldBluePrint bluePrint)
        {
            field.Connections = bluePrint.Connections.Select(c => new Connection {From = c.From, To = c.To}).ToList();
            if (!field.Connections.Any() && bluePrint.AutoGenerateDefaultConnections)
            {
                ExtendConnections(field);
            }

            ComplementAllConnection(field);
            MakeAdditionalBranch(field, bluePrint);
            field.Branches = field.Connections.SelectMany(c => Join(field.GetSection(c.From), field.GetSection(c.To))).ToList();
        }

        private static void ExtendConnections(Field field)
        {
            var targetSection = field.Sections.OrderBy(_ => Random.value).FirstOrDefault();
            while (targetSection != null)
            {
                var nextSection = field.Sections.Where(s => s != targetSection && targetSection.AdjoinWith(s) && field.IsIsolatedSection(s))
                    .OrderBy(_ => Random.value)
                    .FirstOrDefault();
                if (nextSection != null)
                {
                    field.Connections.Add(new Connection{From = targetSection.Index, To = nextSection.Index});
                }
                targetSection = nextSection;
            }
        }

        private static void ComplementAllConnection(Field field)
        {
            var isolatedSection = field.IsolatedAndExistConnectedSectionAroundSections().OrderBy(_ => Random.value).FirstOrDefault();
            while (isolatedSection != null)
            {
                var fromSection = GetAdjoinedSection(field, isolatedSection);
                field.Connections.Add(new Connection{From = fromSection.Index, To = isolatedSection.Index});
                isolatedSection = field.IsolatedAndExistConnectedSectionAroundSections().OrderBy(_ => Random.value).FirstOrDefault();
            }
        }

        private static void MakeAdditionalBranch(Field field, FieldBluePrint bluePrint)
        {
            var randomBranchNum = Random.Range(bluePrint.MinRandomBranchNum, bluePrint.MaxRandomBranchNum + 1);
            for (var i = 0; i < randomBranchNum; i++)
            {
                var targetSection = field.Sections.Where(s => s.ExistRoom).OrderBy(_ => Random.value).FirstOrDefault();
                if (targetSection == null)
                {
                    break;
                }

                var pairSection = field.GetSectionsAdjoinWith(targetSection)
                    .Where(s => !field.Connected(s, targetSection))
                    .OrderBy(_ => Random.value)
                    .FirstOrDefault();
                if (pairSection == null)
                {
                    break;
                }

                field.Connections.Add(new Connection{From =  targetSection.Index, To = pairSection.Index});
            }
        }

        private static Section GetAdjoinedSection(Field field, Section target)
        {
            return field.GetSectionsAdjoinWithRoute(target).OrderBy(_ => Random.value).FirstOrDefault();
        }

        private static IEnumerable<Vector2Int> Join(Section from, Section to)
        {
            var relation = from.AdjoiningWithDirection(to);
            if (relation == Constants.Direction.Error)
            {
                return new Vector2Int[] { };
            }

            var inverse = Constants.Direction.Inverse(relation);

            if (!from.ExistUnconnectedJoints(relation) || !to.ExistUnconnectedJoints(inverse))
            {
                return new Vector2Int[]{};
            }

            var start1 = PickJoint(from, relation);
            var start2 = PickJoint(to, inverse);
            var end1 = from.GetEdge(to, start1);
            var end2 = to.GetEdge(from, start2);

            return new []
            {
                start1.LineTo(end1),
                start2.LineTo(end2),
                end1.LineTo(end2)
            }.SelectMany(p => p);
        }

        private static Vector2Int PickJoint(Section section, int direction)
        {
            if (!section.ExistRoom)
            {
                return section.Relay.Point;
            }

            var joints = section.ExistUnconnectedJoints(direction) ? section.GetUnConnectedJoints(direction).ToList() : section.GetConnectedJoints(direction).ToList();
            var pick = joints[Random.Range(0, joints.Count)];
            pick.Connected = true;
            return pick.Position;
        }
    }
}
